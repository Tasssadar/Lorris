<hr>
<h3 id="desc">Description</h3>
<p>
    Main thing about Lorris is that it's modular - program iself provides only connection to target device, modules do all the work.
    You can run multiple modules at the same time (even connect them to the same port/address/whatever) as tabs, like in web browser.
</p>
<p>
    Lorris is using <a href="http://qt.nokia.com/">Qt Framework (4.7)</a>, which (also) means it is multiplatform - it is tested on 
    Debian Linux(Wheezy, 64bit) and MS Windows(Xp, 7).<br>You can find Windows binaries in
    <a style="cursor: pointer;" onclick="do_scroll('#downloads');">downloads section</a>.
</p>
Available connection types:
<ul>
    <li>Serial Port</li>
    <li>TCP Socket</li>
    <li>Shupito Tunnel - explained <a style="cursor: pointer;" onclick="do_scroll('#shupito_tunnel');">here</a></li>
    <li>None(load from file)</li>
</ul>

<h4>Module: Analyzer</h4>
<i style="margin-left: 30px">Supported connection types: Serial Port, TCP socket, None(load from file)</i>
<p style="margin-left: 30px">
    This module is graphical parser of incomming data, and displays them in user-selected widgets. Incomming data are expected to be in packet format, 
    preferably with some kind of header. Exact packet format is set in <a href="screenshots/analyzer_struct.png">this window</a>,
    it should be pretty self-explanatory.
</p>
<p style="margin-left: 30px">
    <small><i>
        (Image is worth a thousand words, so take a look at <a href="screenshots/analyzer_all.png">this screenshot</a>
        so you can understand what am I talking about)
    </i></small>
    <br>
    Once you have packet structure set-up, you can drag widgets from right bar to main "workspace".
    To assign data to widget, just drag desired byte (or first byte from left side, in case you want to display for example uint32, which is 4 bytes long)
    from top data view to widget. Each widget has it's individual settings, accesible by right-click.
</p>

<div style="margin-left: 30px">
Available widgets:
<ul>
    <li>Number</li>
    <li>Bar</li>
    <li>Color - expects three uint8s as RGB</li>
    <li>Graph</li>
</ul>
</div>

<p style="margin-left: 30px">
    You can also save currect Analyzer configuration and received data to file, so that you do not have set up everything every time you use it.
</p>

<h4>Module: Serial port <-> TCP socket proxy</h4>
<i style="margin-left: 30px">Supported connection types: Serial Port</i>
<p style="margin-left: 30px">
    This module acts as simple proxy between serial port and TCP socket. You can connect from Lorris (or another program) to this proxy via internet network.<br>
    It is kinda awsome, we tested it a while ago so that my friend from across the country programmed a chip laying on my table via this proxy :)
</p>

<h4>Module: Shupito</h4>
<i style="margin-left: 30px">Supported connection types: Serial Port, TCP Socket</i>

<p style="margin-left: 30px">
    This is controling interface for <a href="http://technika.junior.cz/trac/wiki/shupito">Shupito programmer</a>.
    It is programmer of microcontrollers or anything compatible with it. Lorris supports memory read, write and erasing and fuse read and write.
</p>
<div style="margin-left: 30px">
Supported programming interfaces
<ul>
    <li>SPI</li>
    <li>PDI</li>
    <li>Texas Instrument's CC25xx RF-enabled processors</li>
</ul>
</div>

<p id="shupito_tunnel" style="margin-left: 30px">
    It also can utilize Shupito's <b>RSR232 tunnel ability</b>. When you set-up tunnel (see <a href="screenshots/shupito.png">this screenshot</a>, left-top),
    new connection type will appear - "Shupito tunnel". It is basically forwarded serial port, and it acts like one, so every module which use
    serial port connection can also use Shupito tunnel.
</p>

<h4>Module: Terminal</h4>
<i style="margin-left: 30px">Supported connection types: Serial Port, TCP Socket</i>

<p style="margin-left: 30px">
    Standart terminal. It shows incomming data as normal text (and can handle \f, \r, \n and \b control characters)
    or as hex dump (you can chose mode in  top "format" menu).
</p>

<div style="margin-left: 30px">
    Terminal also sends key presses to device, and it can do it in two modes:
    <ol>
        <li><b>Send each key press</b> - sends each character immediately after key press</li>
        <li><b>TCP-terminal-like mode</b> - shows what you type in terminal and sends it only when you press return/enter key</li>
    </ol>
    You can switch between these modes in "Terminal -> Input handling" top menu.
</div>




